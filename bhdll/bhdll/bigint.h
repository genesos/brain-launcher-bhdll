#pragma once

class bigint {
public:
	bigint();
	bigint(std::string init);
	bigint(unsigned char buf[], int length, bool bBigEndian = false);
	bigint(int init);
	bigint(const bigint& init);
	~bigint();

	void Rand(int bytes);
	const unsigned char* GetBytes() const;

	bool operator == (const bigint& rhs) const;
	bool operator != (const bigint& rhs) const;
	bool operator > (const bigint& rhs) const;
	bool operator >= (const bigint& rhs) const;
	bool operator < (const bigint& rhs) const;
	bool operator <= (const bigint& rhs) const;
	bigint& operator = (const bigint& rhs);
	bigint& operator ^= (const bigint& rhs);
	bigint& operator -= (const bigint& rhs);
	bigint& operator += (const bigint& rhs);
	bigint operator + (const bigint& rhs);
	bigint operator - (const bigint& rhs);
	bigint operator % (const bigint& rhs);
	bigint operator / (const bigint& rhs);
	bigint operator * (const bigint& rhs);
	bigint LeftShift() const;
	void LeftShiftIP(); // In-place destructive left shift
	bigint RightShift() const;
	void SetBit(int index, int value);

	std::string ToString() const;

	enum {BASE = 256, MAX_BYTES = 512}; // Allows for up to 4096 bit numbers

	bool DecodeHex(std::string textIn, unsigned char* out, int& outLength) const;
	bool EncodeHex(const unsigned char *bin_data, int bin_len, std::string& textOut) const;

	void Increment();
	static bigint ModularExp(const bigint& a, const bigint& b, const bigint& n);

private:
	int GetBit(int index) const;
	void AddDigit(int value);
	int GetDigit(int index) const;
	void SetDigit(int index, int value);

	void divide(bigint dividend, bigint divisor, bigint& quotient, bigint& remainder);

	BYTE m_Bytes[MAX_BYTES];
	int m_Length;
};

/*
*	Diffie-Hellman public values, generated by Colin Plumb for SKIP.  These
*	values were chosen as representative well-known public values to allay
*	fears of possible trapdoors in self-generated values.  The generation
*	method and actual values can be checked against the SKIP standards
*	document.
*
*	THESE ARE STORED IN BIG-ENDIAN ORDER
*
*/

static unsigned char prime512[] = {
	0xF5, 0x2A, 0xFF, 0x3C, 0xE1, 0xB1, 0x29, 0x40,
	0x18, 0x11, 0x8D, 0x7C, 0x84, 0xA7, 0x0A, 0x72,
	0xD6, 0x86, 0xC4, 0x03, 0x19, 0xC8, 0x07, 0x29,
	0x7A, 0xCA, 0x95, 0x0C, 0xD9, 0x96, 0x9F, 0xAB,
	0xD0, 0x0A, 0x50, 0x9B, 0x02, 0x46, 0xD3, 0x08,
	0x3D, 0x66, 0xA4, 0x5D, 0x41, 0x9F, 0x9C, 0x7C,
	0xBD, 0x89, 0x4B, 0x22, 0x19, 0x26, 0xBA, 0xAB,
	0xA2, 0x5E, 0xC3, 0x55, 0xE9, 0x2A, 0x05, 0x5F
};

static unsigned char prime768[] = {
	0xF3, 0xC9, 0x23, 0xC0, 0x43, 0xF0, 0xA5, 0x5B,
	0x18, 0x8D, 0x8E, 0xBB, 0x55, 0x8C, 0xB8, 0x5D,
	0x38, 0xD3, 0x34, 0xFD, 0x7C, 0x17, 0x57, 0x43,
	0xA3, 0x1D, 0x18, 0x6C, 0xDE, 0x33, 0x21, 0x2C,
	0xB5, 0x2A, 0xFF, 0x3C, 0xE1, 0xB1, 0x29, 0x40,
	0x18, 0x11, 0x8D, 0x7C, 0x84, 0xA7, 0x0A, 0x72,
	0xD6, 0x86, 0xC4, 0x03, 0x19, 0xC8, 0x07, 0x29,
	0x7A, 0xCA, 0x95, 0x0C, 0xD9, 0x96, 0x9F, 0xAB,
	0xD0, 0x0A, 0x50, 0x9B, 0x02, 0x46, 0xD3, 0x08,
	0x3D, 0x66, 0xA4, 0x5D, 0x41, 0x9F, 0x9C, 0x7C,
	0xBD, 0x89, 0x4B, 0x22, 0x19, 0x26, 0xBA, 0xAB,
	0xA2, 0x5E, 0xC3, 0x55, 0xE9, 0x2B, 0x1A, 0xB3
};

static unsigned char prime1024[] = {
	0xF4, 0x88, 0xFD, 0x58, 0x4E, 0x49, 0xDB, 0xCD,
	0x20, 0xB4, 0x9D, 0xE4, 0x91, 0x07, 0x36, 0x6B,
	0x33, 0x6C, 0x38, 0x0D, 0x45, 0x1D, 0x0F, 0x7C,
	0x88, 0xB3, 0x1C, 0x7C, 0x5B, 0x2D, 0x8E, 0xF6,
	0xF3, 0xC9, 0x23, 0xC0, 0x43, 0xF0, 0xA5, 0x5B,
	0x18, 0x8D, 0x8E, 0xBB, 0x55, 0x8C, 0xB8, 0x5D,
	0x38, 0xD3, 0x34, 0xFD, 0x7C, 0x17, 0x57, 0x43,
	0xA3, 0x1D, 0x18, 0x6C, 0xDE, 0x33, 0x21, 0x2C,
	0xB5, 0x2A, 0xFF, 0x3C, 0xE1, 0xB1, 0x29, 0x40,
	0x18, 0x11, 0x8D, 0x7C, 0x84, 0xA7, 0x0A, 0x72,
	0xD6, 0x86, 0xC4, 0x03, 0x19, 0xC8, 0x07, 0x29,
	0x7A, 0xCA, 0x95, 0x0C, 0xD9, 0x96, 0x9F, 0xAB,
	0xD0, 0x0A, 0x50, 0x9B, 0x02, 0x46, 0xD3, 0x08,
	0x3D, 0x66, 0xA4, 0x5D, 0x41, 0x9F, 0x9C, 0x7C,
	0xBD, 0x89, 0x4B, 0x22, 0x19, 0x26, 0xBA, 0xAB,
	0xA2, 0x5E, 0xC3, 0x55, 0xE9, 0x2F, 0x78, 0xC7
};



/*
*
*
Copyright (c) 1998-2001 Aristar, Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The end-user documentation included with the redistribution, if any,
must include the following acknowledgment:

"This product includes software developed by Aristar, Inc. (http://www.aristar.com/)."

Alternately, this acknowledgment may appear in the software itself, if and
wherever such third-party acknowledgments normally appear.

4. The names "Dialect" and "Aristar, Inc." must not be used to endorse or
promote products derived from this software without prior written permission.
For written permission, please contact info@aristar.com.

5. Products derived from this software may not be called "Dialect", nor may
"Dialect" appear in their name, without prior written permission of Aristar, Inc.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
ARISTAR, INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software consists of voluntary contributions made by many individuals
on behalf of Aristar, Inc.  For more information on Aristar, Inc.,
please see <http://www.aristar.com/>.

Portions of this software are based upon software freely available and
written by individuals not associated with Aristar, Inc.  Copyrights are
maintained in the relevant source code files.
*
*
*/



//
//
//	This whole class could use some serious optimizing some day.
//	There is also almost no buffer overflow checking, etc.
//
//

inline bigint::bigint()
{
	m_Length = 0;
	memset(m_Bytes, 0, sizeof(m_Bytes));
}

inline bigint::bigint(const bigint& init)
{
	m_Length = init.m_Length;
	memcpy(m_Bytes, init.m_Bytes, sizeof(m_Bytes));
}

inline bigint::bigint(std::string init)
{
	m_Length = 0;
	memset(m_Bytes, 0, sizeof(m_Bytes));

	if (init.length() != 0) {
		DecodeHex(init, m_Bytes, m_Length);
	}
}

inline bigint::bigint(unsigned char buf[], int length, bool bBigEndian)
{
	memset(m_Bytes, 0, sizeof(m_Bytes));

	m_Length = length;
	if (bBigEndian) {
		for (int idx = 0; idx < length; ++idx) {
			m_Bytes[idx] = buf[length - idx - 1];
		}
	}
	else {
		memcpy(m_Bytes, buf, length);
	}
}

inline bigint::bigint(int init)
{
	m_Length = 0;
	memset(m_Bytes, 0, sizeof(m_Bytes));
	do 
	{
		m_Bytes[m_Length]=init%256;
		init/=256;
		m_Length++;
	} 
	while (init);
}

inline bigint::~bigint(){}
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

inline bool bigint::DecodeHex(std::string textIn, unsigned char* out, int& outLength) const
{
	// x = [:{encoding:"hex"}, "a8f1234":]

	int ascii_count = textIn.length();
	LPCSTR ascii_data, ascii_data_head;
	ascii_data_head = textIn.c_str();
	ascii_data = ascii_data_head + ascii_count - 1; // Walk backwards

	int bin_count = ascii_count / 2 + 1;		// Possible over estimate
	unsigned char *bin_data, *bin_data_head;
	bin_data_head = new unsigned char[bin_count];
	bin_data = bin_data_head + bin_count;		// Walk backwards

	TCHAR ch;
	unsigned char bits = 0, val;
	bin_count = 0;
	while (ascii_data >= ascii_data_head) {
		val = 0;
		ch = *ascii_data--;
		if (ch <= ' ') continue;
		else if ((ch >= '0') && (ch <= '9')) {
			val = ch - '0';
		}
		else if ((ch >= 'a') && (ch <= 'f')) {
			val = ch - 'a' + 10;
		}
		else if ((ch >= 'A') && (ch <= 'F')) {
			val = ch - 'A' + 10;
		}
		else {
			delete[] bin_data_head;
			return false;
		}

		if (bits == 0) {
			--bin_data;
			++bin_count;
			*bin_data = val;
			bits = 4;
		}
		else {
			*bin_data = *bin_data | (val << 4);
			bits = 0;
		}
	}

	// Place data in output buffer (LSB first)
	outLength = bin_count;
	for (int idx = 0; idx < bin_count; ++idx) {
		out[idx] = bin_data[bin_count - idx - 1];
	}

	// Remove zeros from MSB positions
	for (int idx = bin_count - 1; idx >= 0; --idx) {
		if (out[idx] == 0) --outLength;
		else break;
	}

	delete[] bin_data_head;
	return true;
}

static char tohex_table[16] = {
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

inline bool bigint::EncodeHex(const unsigned char *bin_data, int bin_len, std::string& textOut) const
{
	textOut.clear();
	int column = 0;
	for (int idx = bin_len - 1; idx >= 0; --idx) {
		textOut += tohex_table[(bin_data[idx] & 0xF0) >> 4];
		textOut += tohex_table[bin_data[idx] & 0xF];
	}
	return true;
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

inline const unsigned char* bigint::GetBytes() const
{
	return m_Bytes;
}

inline std::string bigint::ToString() const
{
	std::string result;
	if (m_Length == 0) {
		result = ("0");
	}
	else {
		EncodeHex(m_Bytes, m_Length, result);
	}
	return result;
}

inline void bigint::AddDigit(int value)
{
	m_Bytes[m_Length++] = value;
}

inline int bigint::GetDigit(int index) const
{
	return (index < m_Length) ? m_Bytes[index] : 0;
}

inline void bigint::SetDigit(int index, int value)
{
	if (index < m_Length) {
		m_Bytes[index] = value;
	}
	else {
	}
}

inline bigint& bigint::operator = (const bigint& rhs)
{
	m_Length = rhs.m_Length;
	memcpy(m_Bytes, rhs.m_Bytes, sizeof(m_Bytes));
	return *this;
}

inline bigint& bigint::operator ^= (const bigint& rhs)
{
	if (rhs.m_Length > m_Length) {
		// Assumption that the "new" bytes are still zero initialized
		m_Length = rhs.m_Length;
	}

	for (int idx = 0; idx < m_Length; ++idx) {
		m_Bytes[idx] ^= rhs.m_Bytes[idx];
	}
	return *this;
}

inline bool bigint::operator == (const bigint& rhs) const
{
	if (this == &rhs) return true;
	else if (m_Length != rhs.m_Length) {
		if ((m_Length == 0) && (rhs.m_Length == 1)) {
			return rhs.GetDigit(0) == 0;
		}
		else if ((m_Length == 1) && (rhs.m_Length == 0)) {
			return GetDigit(0) == 0;
		}
		return false;
	}
	else {
		return memcmp(m_Bytes, rhs.m_Bytes, m_Length) == 0;
	}
}

inline bool bigint::operator != (const bigint& rhs) const
{
	if (this == &rhs) return false;
	else if (m_Length != rhs.m_Length) {
		if ((m_Length == 0) && (rhs.m_Length == 1)) {
			return rhs.GetDigit(0) != 0;
		}
		else if ((m_Length == 1) && (rhs.m_Length == 0)) {
			return GetDigit(0) != 0;
		}
		return true;
	}
	else {
		return memcmp(m_Bytes, rhs.m_Bytes, m_Length) != 0;
	}
}

inline bool bigint::operator > (const bigint& rhs) const
{
	if (this == &rhs) return false;
	else if (m_Length > rhs.m_Length) return true;
	else if (m_Length < rhs.m_Length) return false;
	else {
		// Compare MSB -> LSB
		for (int idx = m_Length - 1; idx >= 0; --idx) {
			if (m_Bytes[idx] > rhs.m_Bytes[idx]) return true;
			else if (m_Bytes[idx] < rhs.m_Bytes[idx]) return false;
		}
//		ASSERT(*this == rhs);
		return false; // They must be equal if we hit this point
	}
}

inline bool bigint::operator >= (const bigint& rhs) const
{
	if (this == &rhs) return true;
	else if (m_Length > rhs.m_Length) return true;
	else if (m_Length < rhs.m_Length) return false;
	else {
		// Compare MSB -> LSB
		for (int idx = m_Length - 1; idx >= 0; --idx) {
			if (m_Bytes[idx] > rhs.m_Bytes[idx]) return true;
			else if (m_Bytes[idx] < rhs.m_Bytes[idx]) return false;
		}
//		ASSERT(*this == rhs);
		return true; // They must be equal if we hit this point
	}
}

inline bool bigint::operator < (const bigint& rhs) const
{
	if (this == &rhs) return false;
	else if (m_Length < rhs.m_Length) return true;
	else if (m_Length > rhs.m_Length) return false;
	else {
		// Compare MSB -> LSB
		for (int idx = m_Length - 1; idx >= 0; --idx) {
			if (m_Bytes[idx] < rhs.m_Bytes[idx]) return true;
			else if (m_Bytes[idx] > rhs.m_Bytes[idx]) return false;
		}
//		ASSERT(*this == rhs);
		return false; // They must be equal if we hit this point
	}
}

inline bool bigint::operator <= (const bigint& rhs) const
{
	if (this == &rhs) return true;
	else if (m_Length < rhs.m_Length) return true;
	else if (m_Length > rhs.m_Length) return false;
	else {
		// Compare MSB -> LSB
		for (int idx = m_Length - 1; idx >= 0; --idx) {
			if (m_Bytes[idx] < rhs.m_Bytes[idx]) return true;
			else if (m_Bytes[idx] > rhs.m_Bytes[idx]) return false;
		}
//		ASSERT(*this == rhs);
		return true; // They must be equal if we hit this point
	}
}

inline void bigint::Increment()
{
	// Destructively add 1 to this
	int sum = 0;
	int carry = 1;
	for (int idx = 0; idx < m_Length; ++idx) {
		sum = GetDigit(idx) + carry;
		if (sum < 256) {
			SetDigit(idx, sum);
			return;
		}
		else {
			carry = sum >> 8;	//carry = sum / 256;
			sum &= 0xFF;		//sum %= 256;
			SetDigit(idx, sum);
		}
	}

	if (carry != 0) {
		AddDigit(carry);
	}
}

inline bigint& bigint::operator += (const bigint& rhs)
{
	int sum = 0;
	int carry = 0;
	int length = m_Length > rhs.m_Length ? m_Length : rhs.m_Length;

	for (int idx = 0; idx < length; ++idx) {
		sum = GetDigit(idx) + rhs.GetDigit(idx) + carry;
		carry = sum >> 8;	//carry = sum / 256;
		sum &= 0xFF;		//sum %= 256;
		if (idx < m_Length) {
			m_Bytes[idx] = sum;
		}
		else {
			AddDigit(sum);
		}
	}

	if (carry != 0) {
		AddDigit(carry);
	}
	return *this;
}

inline bigint bigint::operator + (const bigint& rhs)
{
	bigint result;

	int sum = 0;
	int carry = 0;
	int length = m_Length > rhs.m_Length ? m_Length : rhs.m_Length;

	for (int idx = 0; idx < length; ++idx) {
		sum = GetDigit(idx) + rhs.GetDigit(idx) + carry;
		carry = sum >> 8;	//carry = sum / 256;
		sum &= 0xFF;		//sum %= 256;
		result.AddDigit(sum);
	}

	if (carry != 0) {
		result.AddDigit(carry);
	}

	return result;
}

inline bigint bigint::operator - (const bigint& rhs)
{
//	ASSERT(*this >= rhs);

	bigint result;

	int diff = 0;
	int borrow = 0;

	for (int idx = 0; idx < m_Length; ++idx) {
		diff = GetDigit(idx) - rhs.GetDigit(idx) - borrow;
		if (diff >= 0) {
			borrow = 0;
		}
		else {
			diff += 256;
			borrow = 1;
		}
		result.AddDigit(diff);
	}

	// Remove zero bytes from MSB
	for (int idx = result.m_Length - 1; idx >= 0; --idx) {
		if (result.m_Bytes[idx] == 0) result.m_Length--;
		else break;
	}

	return result;
}

inline bigint bigint::operator * (const bigint& rhs)
{
	bigint lhs(*this);
	bigint product, temp;
	int digit, sum, carry = 0;

	int lenrhs = rhs.m_Length;
	int lenlhs = lhs.m_Length;

	for (int xx = 0; xx < lenrhs; ++xx) {
		carry = 0;
		digit = rhs.GetDigit(xx);
		temp = bigint();
		for (int aa = 0; aa < xx; ++aa) {
			temp.AddDigit(0);
		}
		for (int yy = 0; yy < lenlhs; ++yy) {
			sum = lhs.GetDigit(yy) * digit + carry;
			carry = sum >> 8;	//carry = sum / 256;
			sum &= 0xFF;		//sum %= 256;
			temp.AddDigit(sum);
		}
		if (carry != 0) {
			temp.AddDigit(carry);
		}
		product += temp;	//product = product + temp;
	}

	return product;
}

inline bigint bigint::operator / (const bigint& rhs)
{
	bigint quotient, remainder;
	divide(*this, rhs, quotient, remainder);
	return quotient;
}

inline bigint bigint::operator % (const bigint& rhs)
{
	bigint quotient, remainder;
	divide(*this, rhs, quotient, remainder);
	return remainder;
}

inline void bigint::divide(bigint dividend, bigint divisor, bigint& quotient, bigint& remainder)
{
	// This is for unsigned division only!!!

	quotient = bigint();
	remainder = bigint();

	if (divisor == bigint()) {
		return; // div-by-zero
	}
	else if (divisor == dividend) {
		quotient.AddDigit(1);
		return;
	}
	else if (divisor > dividend) {
		remainder = dividend;
		return;
	}

	unsigned int bytes = dividend.m_Length > divisor.m_Length ? dividend.m_Length : divisor.m_Length;
	int bits = bytes << 3;
	unsigned int bit;
	bigint d, t;

	while (remainder < divisor) {
		bit = (dividend.GetDigit(bytes - 1) & 0x80) >> 7; // Grab most sig bit

		remainder.LeftShiftIP();
		if (bit) {
			if (remainder.m_Length == 0) remainder.AddDigit(bit);
			else remainder.SetDigit(0, remainder.GetDigit(0) | bit);
		}

		d = dividend;
		dividend.LeftShiftIP();
		--bits;
	}

	// Undo last loop from above
	dividend = d;
	remainder = remainder.RightShift();
	++bits;

	for (int idx = 0; idx < bits; ++idx) {
		remainder.LeftShiftIP();
		if ((dividend.GetDigit(bytes - 1) & 0x80) >> 7) {
			if (remainder.m_Length == 0) remainder.AddDigit(1);
			else remainder.SetDigit(0, remainder.GetDigit(0) | 1);
		}
		dividend.LeftShiftIP();
		quotient.LeftShiftIP();
		if (remainder >= divisor) {
			if (quotient.m_Length == 0) quotient.AddDigit(1);
			else quotient.SetDigit(0, quotient.GetDigit(0) | 1);
			remainder = remainder - divisor;
		}
	}
}

inline void bigint::LeftShiftIP()
{
	// Do:  this = this << 1
	unsigned int digit, carry = 0;
	for (int idx = 0; idx < m_Length; ++idx) {
		digit = m_Bytes[idx];
		if (idx < m_Length) {
			SetDigit(idx, ((digit << 1) | carry) & 0xFF);
		}
		else {
			AddDigit(((digit << 1) | carry) & 0xFF);
		}
		carry = (digit & 0x80) >> 7;
	}
	if (carry) {
		AddDigit(1);
	}
}

inline bigint bigint::LeftShift() const
{
	// Do:  result = this << 1
	bigint result;
	unsigned int digit, carry = 0;
	for (int idx = 0; idx < m_Length; ++idx) {
		digit = m_Bytes[idx];
		result.AddDigit(((digit << 1) | carry) & 0xFF);
		carry = (digit & 0x80) >> 7;
	}
	if (carry) {
		result.AddDigit(1);
	}
	return result;
}

inline bigint bigint::RightShift() const
{
	// Do:  this >> 1
	bigint result;
	unsigned int digit, carry = 0;

	int startIdx = m_Length - 1;
	if (m_Bytes[startIdx] == 1) {
		carry = 0x80;
		--startIdx;
	}
	result.m_Length = startIdx + 1;

	for (int idx = startIdx; idx >= 0; --idx) {
		digit = m_Bytes[idx];
		result.m_Bytes[idx] = ((digit >> 1) | carry) & 0xFF;
		carry = (digit & 1) << 7;
	}
	return result;
}

inline int bigint::GetBit(int index) const
{
	//return (m_Bytes[index >> 3] & (1 << (index & 7))) ? 1 : 0;
	return (m_Bytes[index >> 3] >> (index & 7)) & 0x1;
}

inline void bigint::SetBit(int index, int value)
{
	m_Bytes[index >> 3] |= (1 << (index & 7));
}

inline bigint bigint::ModularExp(const bigint& a, const bigint& b, const bigint& n)
{
	//
	// return (a ^ b) mod n
	// Using algorithm from Introduction to Algorithms page 829
	//
	bigint c;
	bigint d;
	d.AddDigit(1);

	int bytes = b.m_Length;
	int bits = bytes << 3;

	// Trim any leading zeros in the MSB
	while (b.GetBit(bits - 1) == 0)
		--bits;

	for (int idx = bits - 1; idx >= 0; --idx) {
		c.LeftShiftIP(); // Mult by 2
		d = (d * d) % n;
		if (b.GetBit(idx) == 1) {
			c.Increment();	// c = c + 1
			d = (d * a) % n;
		}
	}
	return d;
}

inline void bigint::Rand(int bytes)
{
	// This is not really a crypto level RNG, but it should do for now
	static bool b = true;
	if (b) {
		b = false;
		//		srand(GetTickCount());
	}
	m_Length = bytes;
	for (int idx = 0; idx < bytes; ++idx) {
		m_Bytes[idx] = (rand() ^ idx) & 0xFF;
	}
}
